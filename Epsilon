import heapq
import math

cities = {
    "Caracas": (10.491, -66.9036),  # Latitud, Longitud
    "Maracaibo": (10.6538, -71.6425),
    "Valencia": (10.1633, -68.0029),
    "Barquisimeto": (10.0736, -69.3158),
    "Cumaná": (10.4497, -64.1734),
    # Agregar más ciudades según sea necesario
}


routes = {
    "Caracas": {"Maracaibo": 570, "Valencia": 150, "Barquisimeto": 320, "Cumaná": 360},
    "Maracaibo": {"Caracas": 570, "Valencia": 520, "Barquisimeto": 630, "Cumaná": 640},
    "Valencia": {"Caracas": 150, "Maracaibo": 520, "Barquisimeto": 170, "Cumaná": 250},
    "Barquisimeto": {"Caracas": 320, "Maracaibo": 630, "Valencia": 170, "Cumaná": 450},
    "Cumaná": {"Caracas": 360, "Maracaibo": 640, "Valencia": 250, "Barquisimeto": 450},
}


def haversine(lat1, lon1, lat2, lon2):
    R = 6371  
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = math.sin(dlat / 2) ** 2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c

def heuristic(a, b, epsilon=1.0):

    lat1, lon1 = cities[a]
    lat2, lon2 = cities[b]
    direct_distance = haversine(lat1, lon1, lat2, lon2)
    return epsilon * direct_distance 

def astar(start, goal, epsilon=1.0):

    open_list = []
    heapq.heappush(open_list, (0 + heuristic(start, goal, epsilon), 0, start))  # (f_score, g_score, nodo)
    
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal, epsilon)}
    
    while open_list:
        _, current_g, current = heapq.heappop(open_list)
        
        if current == goal:
            # Reconstruir el camino
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            path.reverse()
            return path
        
        for neighbor, distance in routes[current].items():
            tentative_g_score = current_g + distance 
            
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal, epsilon)
                heapq.heappush(open_list, (f_score[neighbor], tentative_g_score, neighbor))
    
    return None  # Si no hay camino


start_city = "Caracas" 
goal_city = "Maracaibo" 
epsilon = 1.5  

path = astar(start_city, goal_city, epsilon)
if path:
    print("Ruta óptima encontrada:", path)
else:
    print("No se encontró un camino.")
